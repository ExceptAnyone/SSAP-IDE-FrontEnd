{"ast":null,"code":"import React, { useState, useEffect, createContext, useImperativeHandle, useContext, useRef, useMemo, forwardRef } from 'react';\nimport { HTML5Backend, getEmptyImage } from 'react-dnd-html5-backend';\nimport { ResizeObserver } from '@juggle/resize-observer';\nimport { motion } from 'framer-motion';\nimport useMeasure from 'react-use-measure';\nimport { useDragDropManager, useDrag, useDrop, useDragLayer } from 'react-dnd';\nexport { DndProvider } from 'react-dnd';\nimport { PointerTransition, TouchTransition } from 'dnd-multi-backend';\nexport { MultiBackend } from 'dnd-multi-backend';\nimport { TouchBackend } from 'react-dnd-touch-backend';\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nvar _assign = function __assign() {\n  _assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return _assign.apply(this, arguments);\n};\nfunction __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\nfunction AnimateHeight(props) {\n  var isVisible = props.isVisible,\n    _a = props.ease,\n    ease = _a === void 0 ? \"easeIn\" : _a,\n    duration = props.duration,\n    _b = props.variants,\n    variants = _b === void 0 ? {\n      open: {\n        opacity: 1,\n        height: \"auto\"\n      },\n      close: {\n        opacity: 0,\n        height: 0\n      }\n    } : _b,\n    children = props.children;\n  var _c = useMeasure({\n      polyfill: ResizeObserver\n    }),\n    ref = _c[0],\n    height = _c[1].height;\n  var _d = useState(isVisible),\n    isVisibleChildren = _d[0],\n    setIsVisibleChildren = _d[1];\n  var _e = useState(isVisible),\n    isVisibleContainer = _e[0],\n    setIsVisibleContainer = _e[1];\n  var _f = useState(false),\n    transition = _f[0],\n    setTransition = _f[1];\n  var onAnimationComplete = function onAnimationComplete() {\n    setTransition(false);\n    if (!isVisible) {\n      setIsVisibleChildren(false);\n    }\n  };\n  useEffect(function () {\n    setTransition(true);\n    if (isVisible) {\n      setIsVisibleChildren(true);\n    } else {\n      setIsVisibleContainer(false);\n    }\n  }, [isVisible]);\n  useEffect(function () {\n    if (isVisibleChildren) {\n      setIsVisibleContainer(true);\n    }\n  }, [height]);\n  return React.createElement(motion.div, {\n    style: transition ? {\n      overflow: \"hidden\"\n    } : undefined,\n    onAnimationComplete: onAnimationComplete,\n    initial: isVisibleContainer ? \"open\" : \"close\",\n    animate: isVisibleContainer ? \"open\" : \"close\",\n    inherit: false,\n    variants: variants,\n    transition: {\n      ease: ease,\n      duration: computeDuration(height, duration)\n    }\n  }, React.createElement(\"div\", {\n    ref: ref\n  }, isVisibleChildren && children));\n}\nfunction computeDuration(height, fixedDuration) {\n  if (fixedDuration) {\n    return fixedDuration;\n  }\n  if (!height) {\n    return 0;\n  }\n  var constant = height / 36;\n  // ??? don't know why use below computed expression (just copy it from somewhere)\n  return Math.round((4 + 10 * Math.pow(constant, 0.25) + constant / 5) * 10) / 1500;\n}\nvar compareItems = function compareItems(a, b) {\n  if (a.text > b.text) {\n    return 1;\n  } else if (a.text < b.text) {\n    return -1;\n  }\n  return 0;\n};\nvar getTreeItem = function getTreeItem(tree, id) {\n  return tree.find(function (n) {\n    return n.id === id;\n  });\n};\nvar isAncestor = function isAncestor(tree, sourceId, targetId) {\n  if (targetId === 0) {\n    return false;\n  }\n  var targetNode = tree.find(function (node) {\n    return node.id === targetId;\n  });\n  if (targetNode === undefined) {\n    return false;\n  }\n  if (targetNode.parent === sourceId) {\n    return true;\n  }\n  return isAncestor(tree, sourceId, targetNode.parent);\n};\nvar isNodeModel = function isNodeModel(arg) {\n  return arg.id !== undefined && arg.parent !== undefined && arg.text !== undefined;\n};\nvar isDroppable = function isDroppable(dragSource, dropTargetId, treeContext) {\n  var tree = treeContext.tree,\n    rootId = treeContext.rootId,\n    canDrop = treeContext.canDrop;\n  if (dragSource === null) {\n    // Dropability judgment of each node in the undragged state.\n    // Without this process, the newly mounted node will not be able to be dropped unless it is re-rendered\n    if (dropTargetId === rootId) {\n      return true;\n    }\n    var dropTargetNode = tree.find(function (node) {\n      return node.id === dropTargetId;\n    });\n    if (dropTargetNode && dropTargetNode.droppable) {\n      return true;\n    }\n    return false;\n  } else {\n    var dragSourceId_1 = isNodeModel(dragSource) ? dragSource.id : null;\n    if (canDrop) {\n      var result = canDrop(dragSourceId_1, dropTargetId);\n      if (result !== undefined) {\n        return result;\n      }\n    }\n    if (dragSourceId_1 === dropTargetId) {\n      return false;\n    }\n    var dragSourceNode = tree.find(function (node) {\n      return node.id === dragSourceId_1;\n    });\n    var dropTargetNode = tree.find(function (node) {\n      return node.id === dropTargetId;\n    });\n    // dragSource is external node\n    if (dragSourceNode === undefined || dragSourceId_1 === null) {\n      return dropTargetId === rootId || !!(dropTargetNode === null || dropTargetNode === void 0 ? void 0 : dropTargetNode.droppable);\n    }\n    // dropTarget is root node\n    if (dropTargetNode === undefined) {\n      return dragSourceNode.parent !== 0;\n    }\n    if (dragSourceNode.parent === dropTargetId || !dropTargetNode.droppable) {\n      return false;\n    }\n    return !isAncestor(tree, dragSourceId_1, dropTargetId);\n  }\n};\nvar mutateTree = function mutateTree(tree, dragSourceId, dropTargetId) {\n  return tree.map(function (node) {\n    if (node.id === dragSourceId) {\n      return _assign(_assign({}, node), {\n        parent: dropTargetId\n      });\n    }\n    return node;\n  });\n};\nvar getDestIndex = function getDestIndex(tree, dropTargetId, index) {\n  if (index === 0) {\n    return 0;\n  }\n  var siblings = tree.filter(function (node) {\n    return node.parent === dropTargetId;\n  });\n  if (siblings[index]) {\n    return tree.findIndex(function (node) {\n      return node.id === siblings[index].id;\n    });\n  }\n  return tree.findIndex(function (node) {\n    return node.id === siblings[index - 1].id;\n  }) + 1;\n};\nvar getSrcIndex = function getSrcIndex(tree, dragSourceId) {\n  return tree.findIndex(function (node) {\n    return node.id === dragSourceId;\n  });\n};\nvar getModifiedIndex = function getModifiedIndex(tree, dragSourceId, dropTargetId, index) {\n  var srcIndex = getSrcIndex(tree, dragSourceId);\n  var destIndex = getDestIndex(tree, dropTargetId, index);\n  destIndex = destIndex > srcIndex ? destIndex - 1 : destIndex;\n  return [srcIndex, destIndex];\n};\nvar arrayMoveMutable = function arrayMoveMutable(array, fromIndex, toIndex) {\n  var startIndex = fromIndex < 0 ? array.length + fromIndex : fromIndex;\n  if (startIndex >= 0 && startIndex < array.length) {\n    var endIndex = toIndex < 0 ? array.length + toIndex : toIndex;\n    var item = array.splice(fromIndex, 1)[0];\n    array.splice(endIndex, 0, item);\n  }\n};\nvar mutateTreeWithIndex = function mutateTreeWithIndex(tree, dragSourceId, dropTargetId, index) {\n  var _a = getModifiedIndex(tree, dragSourceId, dropTargetId, index),\n    srcIndex = _a[0],\n    destIndex = _a[1];\n  var newTree = __spreadArray([], tree, true);\n  arrayMoveMutable(newTree, srcIndex, destIndex);\n  return newTree.map(function (node) {\n    if (node.id === dragSourceId) {\n      return _assign(_assign({}, node), {\n        parent: dropTargetId\n      });\n    }\n    return node;\n  });\n};\nvar compareYCoord = function compareYCoord(el, pointerY) {\n  var bbox = el.getBoundingClientRect();\n  var centerY = bbox.top + bbox.height / 2;\n  return pointerY > centerY ? \"down\" : \"up\";\n};\nvar getInnerIndex = function getInnerIndex(listItems, monitor) {\n  var pos = \"\";\n  var index = 0;\n  listItems.forEach(function (el, key) {\n    var _a;\n    var flag = compareYCoord(el, ((_a = monitor.getClientOffset()) === null || _a === void 0 ? void 0 : _a.y) || 0);\n    if (pos === \"\") {\n      pos = flag;\n    } else if (pos !== flag) {\n      pos = flag;\n      index = key;\n    }\n    if (key === listItems.length - 1 && flag === \"down\") {\n      index = key + 1;\n    }\n  });\n  return index;\n};\nvar getOuterIndex = function getOuterIndex(node, nodeEl, monitor) {\n  var parentList = nodeEl.closest('[role=\"list\"]');\n  var parentListItems = parentList === null || parentList === void 0 ? void 0 : parentList.querySelectorAll(':scope > [role=\"listitem\"]');\n  if (!parentListItems) {\n    return null;\n  }\n  return getInnerIndex(parentListItems, monitor);\n};\nvar getHoverPosition = function getHoverPosition(el, pointerY, context) {\n  var bbox = el.getBoundingClientRect();\n  var offsetY = context.dropTargetOffset;\n  var upSideY = bbox.top + offsetY;\n  var lowerSideY = bbox.bottom - offsetY;\n  if (pointerY > lowerSideY) {\n    return \"lower\";\n  } else if (pointerY < upSideY) {\n    return \"upper\";\n  }\n  return \"middle\";\n};\nvar getDropTarget = function getDropTarget(node, nodeEl, monitor, context) {\n  var _a;\n  if (!nodeEl) {\n    return null;\n  }\n  if (node === null) {\n    var listItems = nodeEl.querySelectorAll(':scope > [role=\"listitem\"]');\n    return {\n      id: context.rootId,\n      index: getInnerIndex(listItems, monitor)\n    };\n  }\n  var dragSource = monitor.getItem();\n  var list = nodeEl.querySelector('[role=\"list\"]');\n  var hoverPosition = getHoverPosition(nodeEl, ((_a = monitor.getClientOffset()) === null || _a === void 0 ? void 0 : _a.y) || 0, context);\n  if (!list) {\n    if (hoverPosition === \"middle\") {\n      return {\n        id: node.id,\n        index: 0\n      };\n    }\n    if (isDroppable(dragSource, node.parent, context)) {\n      var outerIndex = getOuterIndex(node, nodeEl, monitor);\n      if (outerIndex === null) {\n        return null;\n      }\n      return {\n        id: node.parent,\n        index: outerIndex\n      };\n    }\n    return null;\n  } else {\n    if (hoverPosition === \"upper\") {\n      if (isDroppable(dragSource, node.parent, context)) {\n        var outerIndex = getOuterIndex(node, nodeEl, monitor);\n        if (outerIndex === null) {\n          return null;\n        }\n        return {\n          id: node.parent,\n          index: outerIndex\n        };\n      } else {\n        return {\n          id: node.id,\n          index: 0\n        };\n      }\n    }\n    var listItems = list.querySelectorAll(':scope > [role=\"listitem\"]');\n    return {\n      id: node.id,\n      index: getInnerIndex(listItems, monitor)\n    };\n  }\n};\nvar getDescendants = function getDescendants(treeData, id) {\n  var descendants = [];\n  var search = function search(tree, ids) {\n    var children = tree.filter(function (node) {\n      return ids.includes(node.parent);\n    });\n    if (children.length > 0) {\n      descendants = __spreadArray(__spreadArray([], descendants, true), children, true);\n      search(tree, children.map(function (node) {\n        return node.id;\n      }));\n    }\n  };\n  search(treeData, [id]);\n  return descendants;\n};\n\n/** Get all parental nodes of the given node id. */\nfunction getParents(treeData, id) {\n  var parents = [];\n  var node = treeData.find(function (el) {\n    return el.id === id;\n  });\n  while (node) {\n    node = treeData.find(function (el) {\n      return el.id === node.parent;\n    });\n    if (node) parents.push(node);\n  }\n  return parents;\n}\nvar getBackendOptions = function getBackendOptions(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    backends: [{\n      id: \"html5\",\n      backend: HTML5Backend,\n      options: options.html5,\n      transition: PointerTransition\n    }, {\n      id: \"touch\",\n      backend: TouchBackend,\n      options: options.touch || {\n        enableMouseEvents: true\n      },\n      preview: true,\n      transition: TouchTransition\n    }]\n  };\n};\nvar hasChildNodes = function hasChildNodes(tree, nodeId) {\n  return tree.some(function (node) {\n    return node.parent === nodeId;\n  });\n};\nvar TreeContext = createContext({});\nvar TreeProvider = function TreeProvider(props) {\n  var _a = useOpenIdsHelper(props.tree, props.initialOpen),\n    openIds = _a[0],\n    _b = _a[1],\n    handleToggle = _b.handleToggle,\n    handleCloseAll = _b.handleCloseAll,\n    handleOpenAll = _b.handleOpenAll,\n    handleOpen = _b.handleOpen,\n    handleClose = _b.handleClose;\n  useImperativeHandle(props.treeRef, function () {\n    return {\n      open: function open(targetIds) {\n        return handleOpen(targetIds, props.onChangeOpen);\n      },\n      close: function close(targetIds) {\n        return handleClose(targetIds, props.onChangeOpen);\n      },\n      openAll: function openAll() {\n        return handleOpenAll(props.onChangeOpen);\n      },\n      closeAll: function closeAll() {\n        return handleCloseAll(props.onChangeOpen);\n      }\n    };\n  });\n  var monitor = useDragDropManager().getMonitor();\n  var canDropCallback = props.canDrop;\n  var canDragCallback = props.canDrag;\n  var value = _assign(_assign({\n    extraAcceptTypes: [],\n    listComponent: \"ul\",\n    listItemComponent: \"li\",\n    placeholderComponent: \"li\",\n    sort: true,\n    insertDroppableFirst: true,\n    enableAnimateExpand: false,\n    dropTargetOffset: 0,\n    initialOpen: false\n  }, props), {\n    openIds: openIds,\n    onDrop: function onDrop(dragSource, dropTargetId, placeholderIndex) {\n      // if dragSource is null,\n      // it means that the drop is from the outside of the react-dnd.\n      if (!dragSource) {\n        var options = {\n          dropTargetId: dropTargetId,\n          dropTarget: getTreeItem(props.tree, dropTargetId),\n          monitor: monitor\n        };\n        if (props.sort === false) {\n          options.destinationIndex = getDestIndex(props.tree, dropTargetId, placeholderIndex);\n          options.relativeIndex = placeholderIndex;\n        }\n        props.onDrop(props.tree, options);\n      } else {\n        var options = {\n          dragSourceId: dragSource.id,\n          dropTargetId: dropTargetId,\n          dragSource: dragSource,\n          dropTarget: getTreeItem(props.tree, dropTargetId),\n          monitor: monitor\n        };\n        var tree = props.tree;\n        // If the dragSource does not exist in the tree,\n        // it is an external node, so add it to the tree\n        if (!getTreeItem(tree, dragSource.id)) {\n          tree = __spreadArray(__spreadArray([], tree, true), [dragSource], false);\n        }\n        if (props.sort === false) {\n          var _a = getModifiedIndex(tree, dragSource.id, dropTargetId, placeholderIndex),\n            destIndex = _a[1];\n          options.destinationIndex = destIndex;\n          options.relativeIndex = placeholderIndex;\n          props.onDrop(mutateTreeWithIndex(tree, dragSource.id, dropTargetId, placeholderIndex), options);\n          return;\n        }\n        props.onDrop(mutateTree(tree, dragSource.id, dropTargetId), options);\n      }\n    },\n    canDrop: canDropCallback ? function (dragSourceId, dropTargetId) {\n      return canDropCallback(props.tree, {\n        dragSourceId: dragSourceId !== null && dragSourceId !== void 0 ? dragSourceId : undefined,\n        dropTargetId: dropTargetId,\n        dragSource: monitor.getItem(),\n        dropTarget: getTreeItem(props.tree, dropTargetId),\n        monitor: monitor\n      });\n    } : undefined,\n    canDrag: canDragCallback ? function (id) {\n      return canDragCallback(getTreeItem(props.tree, id));\n    } : undefined,\n    onToggle: function onToggle(id) {\n      return handleToggle(id, props.onChangeOpen);\n    }\n  });\n  return React.createElement(TreeContext.Provider, {\n    value: value\n  }, props.children);\n};\nvar DragControlContext = createContext({});\nvar initialState$1 = {\n  isLock: false\n};\nvar DragControlProvider = function DragControlProvider(props) {\n  var _a = useState(initialState$1.isLock),\n    isLock = _a[0],\n    setIsLock = _a[1];\n  return React.createElement(DragControlContext.Provider, {\n    value: {\n      isLock: isLock,\n      lock: function lock() {\n        return setIsLock(true);\n      },\n      unlock: function unlock() {\n        return setIsLock(false);\n      }\n    }\n  }, props.children);\n};\nvar PlaceholderContext = createContext({});\nvar initialState = {\n  dropTargetId: undefined,\n  index: undefined\n};\nvar PlaceholderProvider = function PlaceholderProvider(props) {\n  var _a = useState(initialState.dropTargetId),\n    dropTargetId = _a[0],\n    setDropTargetId = _a[1];\n  var _b = useState(initialState.index),\n    index = _b[0],\n    setIndex = _b[1];\n  var showPlaceholder = function showPlaceholder(dropTargetId, index) {\n    setDropTargetId(dropTargetId);\n    setIndex(index);\n  };\n  var hidePlaceholder = function hidePlaceholder() {\n    setDropTargetId(initialState.dropTargetId);\n    setIndex(initialState.index);\n  };\n  return React.createElement(PlaceholderContext.Provider, {\n    value: {\n      dropTargetId: dropTargetId,\n      index: index,\n      showPlaceholder: showPlaceholder,\n      hidePlaceholder: hidePlaceholder\n    }\n  }, props.children);\n};\nvar Providers = function Providers(props) {\n  return React.createElement(TreeProvider, _assign({}, props), React.createElement(DragControlProvider, null, React.createElement(PlaceholderProvider, null, props.children)));\n};\n\n/**\n * This is a hook to allow text selection by mouse in the text input area in a node.\n * Temporarily disables node dragging while the pointer is over the text input area.\n */\nvar useDragControl = function useDragControl(ref) {\n  var dragControlContext = useContext(DragControlContext);\n  useEffect(function () {\n    if (!ref.current) return;\n    var node = ref.current;\n    var lock = function lock(e) {\n      var target = e.target;\n      if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {\n        dragControlContext.lock();\n      }\n    };\n    var unlock = function unlock(e) {\n      var target = e.target;\n      if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {\n        dragControlContext.unlock();\n      }\n    };\n    var handleMouseOver = function handleMouseOver(e) {\n      return lock(e);\n    };\n    var handleMouseOut = function handleMouseOut(e) {\n      return unlock(e);\n    };\n    var handleFocusIn = function handleFocusIn(e) {\n      return lock(e);\n    };\n    var handleFocusOut = function handleFocusOut(e) {\n      return unlock(e);\n    };\n    // In Firefox or Safari,\n    // the focusout event is not fired when the focused element is unmounted.\n    // Therefore, it detects the unmounting of a child element\n    // and unlocks tree if the focus is on the body element after unmounting.\n    var observer = new MutationObserver(function () {\n      if (document.activeElement === document.body) {\n        dragControlContext.unlock();\n      }\n    });\n    observer.observe(node, {\n      subtree: true,\n      childList: true\n    });\n    node.addEventListener(\"mouseover\", handleMouseOver);\n    node.addEventListener(\"mouseout\", handleMouseOut);\n    node.addEventListener(\"focusin\", handleFocusIn);\n    node.addEventListener(\"focusout\", handleFocusOut);\n    return function () {\n      observer.disconnect();\n      node.removeEventListener(\"mouseover\", handleMouseOver);\n      node.removeEventListener(\"mouseout\", handleMouseOut);\n      node.removeEventListener(\"focusin\", handleFocusIn);\n      node.removeEventListener(\"focusout\", handleFocusOut);\n    };\n  }, [ref, dragControlContext]);\n  useEffect(function () {\n    var _a;\n    (_a = ref.current) === null || _a === void 0 ? void 0 : _a.setAttribute(\"draggable\", dragControlContext.isLock ? \"false\" : \"true\");\n  }, [ref, dragControlContext.isLock]);\n};\nvar ItemTypes = {\n  TREE_ITEM: Symbol()\n};\nvar dragSourceElement = null;\nvar register = function register(e) {\n  var target = e.target;\n  if (target instanceof HTMLElement) {\n    var source = target.closest('[role=\"listitem\"]');\n    if (e.currentTarget === source) {\n      dragSourceElement = source;\n    }\n  }\n};\nvar handleDragStart = function handleDragStart(e) {\n  return register(e);\n};\nvar handleTouchStart = function handleTouchStart(e) {\n  return register(e);\n};\nvar useDragNode = function useDragNode(_item, ref) {\n  var treeContext = useTreeContext();\n  useEffect(function () {\n    var node = ref.current;\n    node === null || node === void 0 ? void 0 : node.addEventListener(\"dragstart\", handleDragStart);\n    node === null || node === void 0 ? void 0 : node.addEventListener(\"touchstart\", handleTouchStart, {\n      passive: true\n    });\n    return function () {\n      node === null || node === void 0 ? void 0 : node.removeEventListener(\"dragstart\", handleDragStart);\n      node === null || node === void 0 ? void 0 : node.removeEventListener(\"touchstart\", handleTouchStart);\n    };\n  }, [ref]);\n  var _a = useDrag({\n      type: ItemTypes.TREE_ITEM,\n      item: function item(monitor) {\n        var dragItem = _assign({\n          ref: ref\n        }, _item);\n        if (treeContext.onDragStart) {\n          treeContext.onDragStart(dragItem, monitor);\n        }\n        return dragItem;\n      },\n      end: function end(item, monitor) {\n        var dragItem = item;\n        if (treeContext.onDragEnd) {\n          treeContext.onDragEnd(dragItem, monitor);\n        }\n      },\n      canDrag: function canDrag() {\n        var canDrag = treeContext.canDrag;\n        if (dragSourceElement !== ref.current) {\n          return false;\n        }\n        if (canDrag) {\n          return canDrag(_item.id);\n        }\n        return true;\n      },\n      collect: function collect(monitor) {\n        return {\n          isDragging: monitor.isDragging()\n        };\n      }\n    }),\n    isDragging = _a[0].isDragging,\n    drag = _a[1],\n    preview = _a[2];\n  return [isDragging, drag, preview];\n};\nvar useDragOver = function useDragOver(id, isOpen, dragOverHandler) {\n  var stack = useRef(0);\n  var timer = useRef(0);\n  var onDragEnter = function onDragEnter() {\n    stack.current += 1;\n    if (stack.current === 1 && !isOpen) {\n      timer.current = window.setTimeout(function () {\n        return dragOverHandler(id);\n      }, 500);\n    }\n  };\n  var onDragLeave = function onDragLeave() {\n    stack.current -= 1;\n    if (stack.current === 0) {\n      window.clearTimeout(timer.current);\n    }\n  };\n  var onDrop = function onDrop() {\n    if (timer.current > 0) {\n      window.clearTimeout(timer.current);\n    }\n    stack.current = 0;\n    timer.current = 0;\n  };\n  return {\n    onDragEnter: onDragEnter,\n    onDragLeave: onDragLeave,\n    onDrop: onDrop\n  };\n};\nvar useDropRoot = function useDropRoot(ref) {\n  var treeContext = useTreeContext();\n  var placeholderContext = useContext(PlaceholderContext);\n  var _a = useDrop({\n      accept: __spreadArray([ItemTypes.TREE_ITEM], treeContext.extraAcceptTypes, true),\n      drop: function drop(dragItem, monitor) {\n        var rootId = treeContext.rootId,\n          onDrop = treeContext.onDrop;\n        var dropTargetId = placeholderContext.dropTargetId,\n          index = placeholderContext.index;\n        if (monitor.isOver({\n          shallow: true\n        }) && dropTargetId !== undefined && index !== undefined) {\n          // If the drag source is outside the react-dnd,\n          // a different object is passed than the NodeModel.\n          onDrop(isNodeModel(dragItem) ? dragItem : null, rootId, index);\n        }\n        placeholderContext.hidePlaceholder();\n      },\n      canDrop: function canDrop(dragItem, monitor) {\n        var rootId = treeContext.rootId;\n        if (monitor.isOver({\n          shallow: true\n        })) {\n          if (dragItem === undefined) {\n            return false;\n          }\n          return isDroppable(dragItem, rootId, treeContext);\n        }\n        return false;\n      },\n      hover: function hover(dragItem, monitor) {\n        if (monitor.isOver({\n          shallow: true\n        })) {\n          var rootId = treeContext.rootId;\n          var dropTargetId = placeholderContext.dropTargetId,\n            index = placeholderContext.index,\n            showPlaceholder = placeholderContext.showPlaceholder,\n            hidePlaceholder = placeholderContext.hidePlaceholder;\n          var dropTarget = getDropTarget(null, ref.current, monitor, treeContext);\n          if (dropTarget === null || !isDroppable(dragItem, rootId, treeContext)) {\n            hidePlaceholder();\n            return;\n          }\n          if (dropTarget.id !== dropTargetId || dropTarget.index !== index) {\n            showPlaceholder(dropTarget.id, dropTarget.index);\n          }\n        }\n      },\n      collect: function collect(monitor) {\n        var dragSource = monitor.getItem();\n        return {\n          isOver: monitor.isOver({\n            shallow: true\n          }) && monitor.canDrop(),\n          dragSource: dragSource\n        };\n      }\n    }),\n    _b = _a[0],\n    isOver = _b.isOver,\n    dragSource = _b.dragSource,\n    drop = _a[1];\n  return [isOver, dragSource, drop];\n};\nvar useDropNode = function useDropNode(item, ref) {\n  var treeContext = useTreeContext();\n  var placeholderContext = useContext(PlaceholderContext);\n  var _a = useDrop({\n      accept: __spreadArray([ItemTypes.TREE_ITEM], treeContext.extraAcceptTypes, true),\n      drop: function drop(dragItem, monitor) {\n        var dropTargetId = placeholderContext.dropTargetId,\n          index = placeholderContext.index;\n        if (monitor.isOver({\n          shallow: true\n        }) && dropTargetId !== undefined && index !== undefined) {\n          // If the drag source is outside the react-dnd,\n          // a different object is passed than the NodeModel.\n          treeContext.onDrop(isNodeModel(dragItem) ? dragItem : null, dropTargetId, index);\n        }\n        placeholderContext.hidePlaceholder();\n      },\n      canDrop: function canDrop(dragItem, monitor) {\n        if (monitor.isOver({\n          shallow: true\n        })) {\n          var dropTarget = getDropTarget(item, ref.current, monitor, treeContext);\n          if (dropTarget === null) {\n            return false;\n          }\n          return isDroppable(dragItem, dropTarget.id, treeContext);\n        }\n        return false;\n      },\n      hover: function hover(dragItem, monitor) {\n        if (monitor.isOver({\n          shallow: true\n        })) {\n          var dropTargetId = placeholderContext.dropTargetId,\n            index = placeholderContext.index,\n            showPlaceholder = placeholderContext.showPlaceholder,\n            hidePlaceholder = placeholderContext.hidePlaceholder;\n          var dropTarget = getDropTarget(item, ref.current, monitor, treeContext);\n          if (dropTarget === null || !isDroppable(dragItem, dropTarget.id, treeContext)) {\n            hidePlaceholder();\n            return;\n          }\n          if (dropTarget.id !== dropTargetId || dropTarget.index !== index) {\n            showPlaceholder(dropTarget.id, dropTarget.index);\n          }\n        }\n      },\n      collect: function collect(monitor) {\n        var dragSource = monitor.getItem();\n        return {\n          isOver: monitor.isOver({\n            shallow: true\n          }) && monitor.canDrop(),\n          dragSource: dragSource\n        };\n      }\n    }),\n    _b = _a[0],\n    isOver = _b.isOver,\n    dragSource = _b.dragSource,\n    drop = _a[1];\n  return [isOver, dragSource, drop];\n};\nvar useOpenIdsHelper = function useOpenIdsHelper(tree, initialOpen) {\n  // Only a parent node with a child node can be opened.\n  // The droppable property has no effect.\n  // However, if an ID is specified, It is applied unconditionally.\n  var initialOpenIds = useMemo(function () {\n    if (initialOpen === true) {\n      return tree.filter(function (node) {\n        return hasChildNodes(tree, node.id);\n      }).map(function (node) {\n        return node.id;\n      });\n    } else if (Array.isArray(initialOpen)) {\n      return initialOpen;\n    }\n    return [];\n  }, [initialOpen]);\n  var _a = useState(initialOpenIds),\n    openIds = _a[0],\n    setOpenIds = _a[1];\n  useEffect(function () {\n    return setOpenIds(initialOpenIds);\n  }, [initialOpen]);\n  var handleToggle = function handleToggle(targetId, callback) {\n    var newOpenIds = openIds.includes(targetId) ? openIds.filter(function (id) {\n      return id !== targetId;\n    }) : __spreadArray(__spreadArray([], openIds, true), [targetId], false);\n    setOpenIds(newOpenIds);\n    if (callback) {\n      callback(newOpenIds);\n    }\n  };\n  var handleCloseAll = function handleCloseAll(callback) {\n    setOpenIds([]);\n    if (callback) {\n      callback([]);\n    }\n  };\n  var handleOpenAll = function handleOpenAll(callback) {\n    var newOpenIds = tree.filter(function (node) {\n      return hasChildNodes(tree, node.id);\n    }).map(function (node) {\n      return node.id;\n    });\n    setOpenIds(newOpenIds);\n    if (callback) {\n      callback(newOpenIds);\n    }\n  };\n  var handleOpen = function handleOpen(targetIds, callback) {\n    var newOpenIds = [];\n    if (Array.isArray(targetIds)) {\n      var targetNodes = tree.filter(function (node) {\n        return targetIds.includes(node.id) && hasChildNodes(tree, node.id);\n      });\n      newOpenIds = __spreadArray(__spreadArray([], openIds, true), targetNodes.map(function (node) {\n        return node.id;\n      }), true).filter(function (value, index, self) {\n        return self.indexOf(value) === index;\n      });\n    } else {\n      newOpenIds = openIds.includes(targetIds) ? openIds : __spreadArray(__spreadArray([], openIds, true), [targetIds], false);\n    }\n    setOpenIds(newOpenIds);\n    if (callback) {\n      callback(newOpenIds);\n    }\n  };\n  var handleClose = function handleClose(targetIds, callback) {\n    var newOpenIds = openIds.filter(function (id) {\n      return Array.isArray(targetIds) ? !targetIds.includes(id) : id !== targetIds;\n    });\n    setOpenIds(newOpenIds);\n    if (callback) {\n      callback(newOpenIds);\n    }\n  };\n  return [openIds, {\n    handleToggle: handleToggle,\n    handleCloseAll: handleCloseAll,\n    handleOpenAll: handleOpenAll,\n    handleOpen: handleOpen,\n    handleClose: handleClose\n  }];\n};\nvar useTreeDragLayer = function useTreeDragLayer() {\n  return useDragLayer(function (monitor) {\n    var itemType = monitor.getItemType();\n    return {\n      item: monitor.getItem(),\n      clientOffset: monitor.getClientOffset(),\n      isDragging: monitor.isDragging() && itemType === ItemTypes.TREE_ITEM\n    };\n  });\n};\nvar useTreeContext = function useTreeContext() {\n  var treeContext = useContext(TreeContext);\n  if (!treeContext) {\n    throw new Error(\"useTreeContext must be used under TreeProvider\");\n  }\n  return treeContext;\n};\nvar useContainerClassName = function useContainerClassName(parentId, isOver) {\n  var _a = useTreeContext(),\n    rootId = _a.rootId,\n    rootProps = _a.rootProps,\n    classes = _a.classes;\n  var className = (classes === null || classes === void 0 ? void 0 : classes.container) || \"\";\n  if (isOver && (classes === null || classes === void 0 ? void 0 : classes.dropTarget)) {\n    className = \"\".concat(className, \" \").concat(classes.dropTarget);\n  }\n  if (parentId === rootId && (classes === null || classes === void 0 ? void 0 : classes.root)) {\n    className = \"\".concat(className, \" \").concat(classes.root);\n  }\n  if (parentId === rootId && (rootProps === null || rootProps === void 0 ? void 0 : rootProps.className)) {\n    className = \"\".concat(className, \" \").concat(rootProps.className);\n  }\n  className = className.trim();\n  return className;\n};\nvar useDragHandle = function useDragHandle(containerRef, handleRef, drag) {\n  if (handleRef.current) {\n    drag(handleRef);\n  } else {\n    drag(containerRef);\n  }\n  useEffect(function () {\n    if (handleRef.current) {\n      drag(handleRef);\n    } else {\n      drag(containerRef);\n    }\n  }, [handleRef.current]);\n};\nvar Node = function Node(props) {\n  var treeContext = useTreeContext();\n  var placeholderContext = useContext(PlaceholderContext);\n  var containerRef = useRef(null);\n  var handleRef = useRef(null);\n  var item = treeContext.tree.find(function (node) {\n    return node.id === props.id;\n  });\n  var openIds = treeContext.openIds,\n    classes = treeContext.classes,\n    enableAnimateExpand = treeContext.enableAnimateExpand;\n  var open = openIds.includes(props.id);\n  var _a = useDragNode(item, containerRef),\n    isDragging = _a[0],\n    drag = _a[1],\n    preview = _a[2];\n  var _b = useDropNode(item, containerRef),\n    isOver = _b[0],\n    dragSource = _b[1],\n    drop = _b[2];\n  useDragHandle(containerRef, handleRef, drag);\n  if (isDroppable(dragSource, props.id, treeContext)) {\n    drop(containerRef);\n  }\n  useEffect(function () {\n    if (treeContext.dragPreviewRender) {\n      preview(getEmptyImage(), {\n        captureDraggingState: true\n      });\n    } else if (handleRef.current) {\n      preview(containerRef);\n    }\n  }, [preview, treeContext.dragPreviewRender]);\n  useDragControl(containerRef);\n  var handleToggle = function handleToggle() {\n    return treeContext.onToggle(item.id);\n  };\n  var Component = treeContext.listItemComponent;\n  var className = (classes === null || classes === void 0 ? void 0 : classes.listItem) || \"\";\n  if (isOver && (classes === null || classes === void 0 ? void 0 : classes.dropTarget)) {\n    className = \"\".concat(className, \" \").concat(classes.dropTarget);\n  }\n  if (isDragging && (classes === null || classes === void 0 ? void 0 : classes.draggingSource)) {\n    className = \"\".concat(className, \" \").concat(classes.draggingSource);\n  }\n  var draggable = treeContext.canDrag ? treeContext.canDrag(props.id) : true;\n  var isDropTarget = placeholderContext.dropTargetId === props.id;\n  var params = {\n    depth: props.depth,\n    isOpen: open,\n    isDragging: isDragging,\n    isDropTarget: isDropTarget,\n    draggable: draggable,\n    hasChild: hasChildNodes(treeContext.tree, props.id),\n    containerRef: containerRef,\n    handleRef: handleRef,\n    onToggle: handleToggle\n  };\n  return React.createElement(Component, {\n    ref: containerRef,\n    className: className,\n    role: \"listitem\"\n  }, treeContext.render(item, params), enableAnimateExpand && params.hasChild && React.createElement(AnimateHeight, {\n    isVisible: open\n  }, React.createElement(Container, {\n    parentId: props.id,\n    depth: props.depth + 1\n  })), !enableAnimateExpand && params.hasChild && open && React.createElement(Container, {\n    parentId: props.id,\n    depth: props.depth + 1\n  }));\n};\nvar Placeholder = function Placeholder(props) {\n  var _a = useTreeContext(),\n    placeholderRender = _a.placeholderRender,\n    Component = _a.placeholderComponent,\n    classes = _a.classes;\n  var placeholderContext = useContext(PlaceholderContext);\n  var manager = useDragDropManager();\n  var monitor = manager.getMonitor();\n  var dragSource = monitor.getItem();\n  if (!placeholderRender || !dragSource) {\n    return null;\n  }\n  var visible = props.dropTargetId === placeholderContext.dropTargetId && (props.index === placeholderContext.index || props.index === undefined && props.listCount === placeholderContext.index);\n  if (!visible) {\n    return null;\n  }\n  return React.createElement(Component, {\n    className: (classes === null || classes === void 0 ? void 0 : classes.placeholder) || \"\"\n  }, placeholderRender(dragSource, {\n    depth: props.depth\n  }));\n};\nvar Container = function Container(props) {\n  var treeContext = useTreeContext();\n  var ref = useRef(null);\n  var nodes = treeContext.tree.filter(function (l) {\n    return l.parent === props.parentId;\n  });\n  var view = nodes;\n  var sortCallback = typeof treeContext.sort === \"function\" ? treeContext.sort : compareItems;\n  if (treeContext.insertDroppableFirst) {\n    var droppableNodes = nodes.filter(function (n) {\n      return n.droppable;\n    });\n    var nonDroppableNodes = nodes.filter(function (n) {\n      return !n.droppable;\n    });\n    if (treeContext.sort === false) {\n      view = __spreadArray(__spreadArray([], droppableNodes, true), nonDroppableNodes, true);\n    } else {\n      droppableNodes = droppableNodes.sort(sortCallback);\n      nonDroppableNodes = nonDroppableNodes.sort(sortCallback);\n      view = __spreadArray(__spreadArray([], droppableNodes, true), nonDroppableNodes, true);\n    }\n  } else {\n    if (treeContext.sort !== false) {\n      view = nodes.sort(sortCallback);\n    }\n  }\n  var _a = useDropRoot(ref),\n    isOver = _a[0],\n    dragSource = _a[1],\n    drop = _a[2];\n  if (props.parentId === treeContext.rootId && isDroppable(dragSource, treeContext.rootId, treeContext)) {\n    drop(ref);\n  }\n  var className = useContainerClassName(props.parentId, isOver);\n  var rootProps = treeContext.rootProps || {};\n  var Component = treeContext.listComponent;\n  return React.createElement(Component, _assign({\n    ref: ref,\n    role: \"list\"\n  }, rootProps, {\n    className: className\n  }), view.map(function (node, index) {\n    return React.createElement(React.Fragment, {\n      key: node.id\n    }, React.createElement(Placeholder, {\n      depth: props.depth,\n      listCount: view.length,\n      dropTargetId: props.parentId,\n      index: index\n    }), React.createElement(Node, {\n      id: node.id,\n      depth: props.depth\n    }));\n  }), React.createElement(Placeholder, {\n    depth: props.depth,\n    listCount: view.length,\n    dropTargetId: props.parentId\n  }));\n};\nvar rootStyle = {\n  height: \"100%\",\n  left: 0,\n  pointerEvents: \"none\",\n  position: \"fixed\",\n  top: 0,\n  width: \"100%\",\n  zIndex: 100\n};\nvar getItemStyles = function getItemStyles(monitorProps) {\n  var offset = monitorProps.clientOffset;\n  if (!offset) {\n    return {};\n  }\n  var x = offset.x,\n    y = offset.y;\n  var transform = \"translate(\".concat(x, \"px, \").concat(y, \"px)\");\n  return {\n    pointerEvents: \"none\",\n    transform: transform\n  };\n};\nvar DragLayer = function DragLayer() {\n  var context = useTreeContext();\n  var monitorProps = useTreeDragLayer();\n  var isDragging = monitorProps.isDragging,\n    clientOffset = monitorProps.clientOffset;\n  if (!isDragging || !clientOffset) {\n    return null;\n  }\n  return React.createElement(\"div\", {\n    style: rootStyle\n  }, React.createElement(\"div\", {\n    style: getItemStyles(monitorProps)\n  }, context.dragPreviewRender && context.dragPreviewRender(monitorProps)));\n};\nfunction TreeInner(props, ref) {\n  return React.createElement(Providers, _assign({}, props, {\n    treeRef: ref\n  }), props.dragPreviewRender && React.createElement(DragLayer, null), React.createElement(Container, {\n    parentId: props.rootId,\n    depth: 0\n  }));\n}\nvar Tree = forwardRef(TreeInner);\nexport { Container, DragLayer, ItemTypes, Node, Tree, compareItems, getBackendOptions, getDescendants, getDestIndex, getDropTarget, getModifiedIndex, getParents, getTreeItem, hasChildNodes, isAncestor, isDroppable, isNodeModel, mutateTree, mutateTreeWithIndex, useContainerClassName, useDragControl, useDragHandle, useDragNode, useDragOver, useDropNode, useDropRoot, useOpenIdsHelper, useTreeContext, useTreeDragLayer };","map":{"version":3,"names":[],"sources":[],"sourcesContent":["import React, { useState, useEffect, createContext, useImperativeHandle, useContext, useRef, useMemo, forwardRef } from 'react';\nimport { HTML5Backend, getEmptyImage } from 'react-dnd-html5-backend';\nimport { ResizeObserver } from '@juggle/resize-observer';\nimport { motion } from 'framer-motion';\nimport useMeasure from 'react-use-measure';\nimport { useDragDropManager, useDrag, useDrop, useDragLayer } from 'react-dnd';\nexport { DndProvider } from 'react-dnd';\nimport { PointerTransition, TouchTransition } from 'dnd-multi-backend';\nexport { MultiBackend } from 'dnd-multi-backend';\nimport { TouchBackend } from 'react-dnd-touch-backend';\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\n\nfunction AnimateHeight(props) {\n    var isVisible = props.isVisible, _a = props.ease, ease = _a === void 0 ? \"easeIn\" : _a, duration = props.duration, _b = props.variants, variants = _b === void 0 ? {\n        open: { opacity: 1, height: \"auto\" },\n        close: { opacity: 0, height: 0 },\n    } : _b, children = props.children;\n    var _c = useMeasure({ polyfill: ResizeObserver }), ref = _c[0], height = _c[1].height;\n    var _d = useState(isVisible), isVisibleChildren = _d[0], setIsVisibleChildren = _d[1];\n    var _e = useState(isVisible), isVisibleContainer = _e[0], setIsVisibleContainer = _e[1];\n    var _f = useState(false), transition = _f[0], setTransition = _f[1];\n    var onAnimationComplete = function () {\n        setTransition(false);\n        if (!isVisible) {\n            setIsVisibleChildren(false);\n        }\n    };\n    useEffect(function () {\n        setTransition(true);\n        if (isVisible) {\n            setIsVisibleChildren(true);\n        }\n        else {\n            setIsVisibleContainer(false);\n        }\n    }, [isVisible]);\n    useEffect(function () {\n        if (isVisibleChildren) {\n            setIsVisibleContainer(true);\n        }\n    }, [height]);\n    return (React.createElement(motion.div, { style: transition ? { overflow: \"hidden\" } : undefined, onAnimationComplete: onAnimationComplete, initial: isVisibleContainer ? \"open\" : \"close\", animate: isVisibleContainer ? \"open\" : \"close\", inherit: false, variants: variants, transition: { ease: ease, duration: computeDuration(height, duration) } },\n        React.createElement(\"div\", { ref: ref }, isVisibleChildren && children)));\n}\nfunction computeDuration(height, fixedDuration) {\n    if (fixedDuration) {\n        return fixedDuration;\n    }\n    if (!height) {\n        return 0;\n    }\n    var constant = height / 36;\n    // ??? don't know why use below computed expression (just copy it from somewhere)\n    return Math.round((4 + 10 * Math.pow(constant, 0.25) + constant / 5) * 10) / 1500;\n}\n\nvar compareItems = function (a, b) {\n    if (a.text > b.text) {\n        return 1;\n    }\n    else if (a.text < b.text) {\n        return -1;\n    }\n    return 0;\n};\n\nvar getTreeItem = function (tree, id) { return tree.find(function (n) { return n.id === id; }); };\n\nvar isAncestor = function (tree, sourceId, targetId) {\n    if (targetId === 0) {\n        return false;\n    }\n    var targetNode = tree.find(function (node) { return node.id === targetId; });\n    if (targetNode === undefined) {\n        return false;\n    }\n    if (targetNode.parent === sourceId) {\n        return true;\n    }\n    return isAncestor(tree, sourceId, targetNode.parent);\n};\n\nvar isNodeModel = function (arg) {\n    return (arg.id !== undefined && arg.parent !== undefined && arg.text !== undefined);\n};\n\nvar isDroppable = function (dragSource, dropTargetId, treeContext) {\n    var tree = treeContext.tree, rootId = treeContext.rootId, canDrop = treeContext.canDrop;\n    if (dragSource === null) {\n        // Dropability judgment of each node in the undragged state.\n        // Without this process, the newly mounted node will not be able to be dropped unless it is re-rendered\n        if (dropTargetId === rootId) {\n            return true;\n        }\n        var dropTargetNode = tree.find(function (node) { return node.id === dropTargetId; });\n        if (dropTargetNode && dropTargetNode.droppable) {\n            return true;\n        }\n        return false;\n    }\n    else {\n        var dragSourceId_1 = isNodeModel(dragSource) ? dragSource.id : null;\n        if (canDrop) {\n            var result = canDrop(dragSourceId_1, dropTargetId);\n            if (result !== undefined) {\n                return result;\n            }\n        }\n        if (dragSourceId_1 === dropTargetId) {\n            return false;\n        }\n        var dragSourceNode = tree.find(function (node) { return node.id === dragSourceId_1; });\n        var dropTargetNode = tree.find(function (node) { return node.id === dropTargetId; });\n        // dragSource is external node\n        if (dragSourceNode === undefined || dragSourceId_1 === null) {\n            return dropTargetId === rootId || !!(dropTargetNode === null || dropTargetNode === void 0 ? void 0 : dropTargetNode.droppable);\n        }\n        // dropTarget is root node\n        if (dropTargetNode === undefined) {\n            return dragSourceNode.parent !== 0;\n        }\n        if (dragSourceNode.parent === dropTargetId || !dropTargetNode.droppable) {\n            return false;\n        }\n        return !isAncestor(tree, dragSourceId_1, dropTargetId);\n    }\n};\n\nvar mutateTree = function (tree, dragSourceId, dropTargetId) {\n    return tree.map(function (node) {\n        if (node.id === dragSourceId) {\n            return __assign(__assign({}, node), { parent: dropTargetId });\n        }\n        return node;\n    });\n};\n\nvar getDestIndex = function (tree, dropTargetId, index) {\n    if (index === 0) {\n        return 0;\n    }\n    var siblings = tree.filter(function (node) { return node.parent === dropTargetId; });\n    if (siblings[index]) {\n        return tree.findIndex(function (node) { return node.id === siblings[index].id; });\n    }\n    return tree.findIndex(function (node) { return node.id === siblings[index - 1].id; }) + 1;\n};\n\nvar getSrcIndex = function (tree, dragSourceId) {\n    return tree.findIndex(function (node) { return node.id === dragSourceId; });\n};\nvar getModifiedIndex = function (tree, dragSourceId, dropTargetId, index) {\n    var srcIndex = getSrcIndex(tree, dragSourceId);\n    var destIndex = getDestIndex(tree, dropTargetId, index);\n    destIndex = destIndex > srcIndex ? destIndex - 1 : destIndex;\n    return [srcIndex, destIndex];\n};\n\nvar arrayMoveMutable = function (array, fromIndex, toIndex) {\n    var startIndex = fromIndex < 0 ? array.length + fromIndex : fromIndex;\n    if (startIndex >= 0 && startIndex < array.length) {\n        var endIndex = toIndex < 0 ? array.length + toIndex : toIndex;\n        var item = array.splice(fromIndex, 1)[0];\n        array.splice(endIndex, 0, item);\n    }\n};\nvar mutateTreeWithIndex = function (tree, dragSourceId, dropTargetId, index) {\n    var _a = getModifiedIndex(tree, dragSourceId, dropTargetId, index), srcIndex = _a[0], destIndex = _a[1];\n    var newTree = __spreadArray([], tree, true);\n    arrayMoveMutable(newTree, srcIndex, destIndex);\n    return newTree.map(function (node) {\n        if (node.id === dragSourceId) {\n            return __assign(__assign({}, node), { parent: dropTargetId });\n        }\n        return node;\n    });\n};\n\nvar compareYCoord = function (el, pointerY) {\n    var bbox = el.getBoundingClientRect();\n    var centerY = bbox.top + bbox.height / 2;\n    return pointerY > centerY ? \"down\" : \"up\";\n};\nvar getInnerIndex = function (listItems, monitor) {\n    var pos = \"\";\n    var index = 0;\n    listItems.forEach(function (el, key) {\n        var _a;\n        var flag = compareYCoord(el, ((_a = monitor.getClientOffset()) === null || _a === void 0 ? void 0 : _a.y) || 0);\n        if (pos === \"\") {\n            pos = flag;\n        }\n        else if (pos !== flag) {\n            pos = flag;\n            index = key;\n        }\n        if (key === listItems.length - 1 && flag === \"down\") {\n            index = key + 1;\n        }\n    });\n    return index;\n};\nvar getOuterIndex = function (node, nodeEl, monitor) {\n    var parentList = nodeEl.closest('[role=\"list\"]');\n    var parentListItems = parentList === null || parentList === void 0 ? void 0 : parentList.querySelectorAll(':scope > [role=\"listitem\"]');\n    if (!parentListItems) {\n        return null;\n    }\n    return getInnerIndex(parentListItems, monitor);\n};\nvar getHoverPosition = function (el, pointerY, context) {\n    var bbox = el.getBoundingClientRect();\n    var offsetY = context.dropTargetOffset;\n    var upSideY = bbox.top + offsetY;\n    var lowerSideY = bbox.bottom - offsetY;\n    if (pointerY > lowerSideY) {\n        return \"lower\";\n    }\n    else if (pointerY < upSideY) {\n        return \"upper\";\n    }\n    return \"middle\";\n};\nvar getDropTarget = function (node, nodeEl, monitor, context) {\n    var _a;\n    if (!nodeEl) {\n        return null;\n    }\n    if (node === null) {\n        var listItems = nodeEl.querySelectorAll(':scope > [role=\"listitem\"]');\n        return {\n            id: context.rootId,\n            index: getInnerIndex(listItems, monitor),\n        };\n    }\n    var dragSource = monitor.getItem();\n    var list = nodeEl.querySelector('[role=\"list\"]');\n    var hoverPosition = getHoverPosition(nodeEl, ((_a = monitor.getClientOffset()) === null || _a === void 0 ? void 0 : _a.y) || 0, context);\n    if (!list) {\n        if (hoverPosition === \"middle\") {\n            return {\n                id: node.id,\n                index: 0,\n            };\n        }\n        if (isDroppable(dragSource, node.parent, context)) {\n            var outerIndex = getOuterIndex(node, nodeEl, monitor);\n            if (outerIndex === null) {\n                return null;\n            }\n            return {\n                id: node.parent,\n                index: outerIndex,\n            };\n        }\n        return null;\n    }\n    else {\n        if (hoverPosition === \"upper\") {\n            if (isDroppable(dragSource, node.parent, context)) {\n                var outerIndex = getOuterIndex(node, nodeEl, monitor);\n                if (outerIndex === null) {\n                    return null;\n                }\n                return {\n                    id: node.parent,\n                    index: outerIndex,\n                };\n            }\n            else {\n                return {\n                    id: node.id,\n                    index: 0,\n                };\n            }\n        }\n        var listItems = list.querySelectorAll(':scope > [role=\"listitem\"]');\n        return {\n            id: node.id,\n            index: getInnerIndex(listItems, monitor),\n        };\n    }\n};\n\nvar getDescendants = function (treeData, id) {\n    var descendants = [];\n    var search = function (tree, ids) {\n        var children = tree.filter(function (node) { return ids.includes(node.parent); });\n        if (children.length > 0) {\n            descendants = __spreadArray(__spreadArray([], descendants, true), children, true);\n            search(tree, children.map(function (node) { return node.id; }));\n        }\n    };\n    search(treeData, [id]);\n    return descendants;\n};\n\n/** Get all parental nodes of the given node id. */\nfunction getParents(treeData, id) {\n    var parents = [];\n    var node = treeData.find(function (el) { return el.id === id; });\n    while (node) {\n        node = treeData.find(function (el) { return el.id === node.parent; });\n        if (node)\n            parents.push(node);\n    }\n    return parents;\n}\n\nvar getBackendOptions = function (options) {\n    if (options === void 0) { options = {}; }\n    return {\n        backends: [\n            {\n                id: \"html5\",\n                backend: HTML5Backend,\n                options: options.html5,\n                transition: PointerTransition,\n            },\n            {\n                id: \"touch\",\n                backend: TouchBackend,\n                options: options.touch || { enableMouseEvents: true },\n                preview: true,\n                transition: TouchTransition,\n            },\n        ],\n    };\n};\n\nvar hasChildNodes = function (tree, nodeId) {\n    return tree.some(function (node) { return node.parent === nodeId; });\n};\n\nvar TreeContext = createContext({});\nvar TreeProvider = function (props) {\n    var _a = useOpenIdsHelper(props.tree, props.initialOpen), openIds = _a[0], _b = _a[1], handleToggle = _b.handleToggle, handleCloseAll = _b.handleCloseAll, handleOpenAll = _b.handleOpenAll, handleOpen = _b.handleOpen, handleClose = _b.handleClose;\n    useImperativeHandle(props.treeRef, function () { return ({\n        open: function (targetIds) { return handleOpen(targetIds, props.onChangeOpen); },\n        close: function (targetIds) { return handleClose(targetIds, props.onChangeOpen); },\n        openAll: function () { return handleOpenAll(props.onChangeOpen); },\n        closeAll: function () { return handleCloseAll(props.onChangeOpen); },\n    }); });\n    var monitor = useDragDropManager().getMonitor();\n    var canDropCallback = props.canDrop;\n    var canDragCallback = props.canDrag;\n    var value = __assign(__assign({ extraAcceptTypes: [], listComponent: \"ul\", listItemComponent: \"li\", placeholderComponent: \"li\", sort: true, insertDroppableFirst: true, enableAnimateExpand: false, dropTargetOffset: 0, initialOpen: false }, props), { openIds: openIds, onDrop: function (dragSource, dropTargetId, placeholderIndex) {\n            // if dragSource is null,\n            // it means that the drop is from the outside of the react-dnd.\n            if (!dragSource) {\n                var options = {\n                    dropTargetId: dropTargetId,\n                    dropTarget: getTreeItem(props.tree, dropTargetId),\n                    monitor: monitor,\n                };\n                if (props.sort === false) {\n                    options.destinationIndex = getDestIndex(props.tree, dropTargetId, placeholderIndex);\n                    options.relativeIndex = placeholderIndex;\n                }\n                props.onDrop(props.tree, options);\n            }\n            else {\n                var options = {\n                    dragSourceId: dragSource.id,\n                    dropTargetId: dropTargetId,\n                    dragSource: dragSource,\n                    dropTarget: getTreeItem(props.tree, dropTargetId),\n                    monitor: monitor,\n                };\n                var tree = props.tree;\n                // If the dragSource does not exist in the tree,\n                // it is an external node, so add it to the tree\n                if (!getTreeItem(tree, dragSource.id)) {\n                    tree = __spreadArray(__spreadArray([], tree, true), [dragSource], false);\n                }\n                if (props.sort === false) {\n                    var _a = getModifiedIndex(tree, dragSource.id, dropTargetId, placeholderIndex), destIndex = _a[1];\n                    options.destinationIndex = destIndex;\n                    options.relativeIndex = placeholderIndex;\n                    props.onDrop(mutateTreeWithIndex(tree, dragSource.id, dropTargetId, placeholderIndex), options);\n                    return;\n                }\n                props.onDrop(mutateTree(tree, dragSource.id, dropTargetId), options);\n            }\n        }, canDrop: canDropCallback\n            ? function (dragSourceId, dropTargetId) {\n                return canDropCallback(props.tree, {\n                    dragSourceId: dragSourceId !== null && dragSourceId !== void 0 ? dragSourceId : undefined,\n                    dropTargetId: dropTargetId,\n                    dragSource: monitor.getItem(),\n                    dropTarget: getTreeItem(props.tree, dropTargetId),\n                    monitor: monitor,\n                });\n            }\n            : undefined, canDrag: canDragCallback\n            ? function (id) { return canDragCallback(getTreeItem(props.tree, id)); }\n            : undefined, onToggle: function (id) { return handleToggle(id, props.onChangeOpen); } });\n    return (React.createElement(TreeContext.Provider, { value: value }, props.children));\n};\n\nvar DragControlContext = createContext({});\nvar initialState$1 = {\n    isLock: false,\n};\nvar DragControlProvider = function (props) {\n    var _a = useState(initialState$1.isLock), isLock = _a[0], setIsLock = _a[1];\n    return (React.createElement(DragControlContext.Provider, { value: {\n            isLock: isLock,\n            lock: function () { return setIsLock(true); },\n            unlock: function () { return setIsLock(false); },\n        } }, props.children));\n};\n\nvar PlaceholderContext = createContext({});\nvar initialState = {\n    dropTargetId: undefined,\n    index: undefined,\n};\nvar PlaceholderProvider = function (props) {\n    var _a = useState(initialState.dropTargetId), dropTargetId = _a[0], setDropTargetId = _a[1];\n    var _b = useState(initialState.index), index = _b[0], setIndex = _b[1];\n    var showPlaceholder = function (dropTargetId, index) {\n        setDropTargetId(dropTargetId);\n        setIndex(index);\n    };\n    var hidePlaceholder = function () {\n        setDropTargetId(initialState.dropTargetId);\n        setIndex(initialState.index);\n    };\n    return (React.createElement(PlaceholderContext.Provider, { value: {\n            dropTargetId: dropTargetId,\n            index: index,\n            showPlaceholder: showPlaceholder,\n            hidePlaceholder: hidePlaceholder,\n        } }, props.children));\n};\n\nvar Providers = function (props) { return (React.createElement(TreeProvider, __assign({}, props),\n    React.createElement(DragControlProvider, null,\n        React.createElement(PlaceholderProvider, null, props.children)))); };\n\n/**\n * This is a hook to allow text selection by mouse in the text input area in a node.\n * Temporarily disables node dragging while the pointer is over the text input area.\n */\nvar useDragControl = function (ref) {\n    var dragControlContext = useContext(DragControlContext);\n    useEffect(function () {\n        if (!ref.current)\n            return;\n        var node = ref.current;\n        var lock = function (e) {\n            var target = e.target;\n            if (target instanceof HTMLInputElement ||\n                target instanceof HTMLTextAreaElement) {\n                dragControlContext.lock();\n            }\n        };\n        var unlock = function (e) {\n            var target = e.target;\n            if (target instanceof HTMLInputElement ||\n                target instanceof HTMLTextAreaElement) {\n                dragControlContext.unlock();\n            }\n        };\n        var handleMouseOver = function (e) { return lock(e); };\n        var handleMouseOut = function (e) { return unlock(e); };\n        var handleFocusIn = function (e) { return lock(e); };\n        var handleFocusOut = function (e) { return unlock(e); };\n        // In Firefox or Safari,\n        // the focusout event is not fired when the focused element is unmounted.\n        // Therefore, it detects the unmounting of a child element\n        // and unlocks tree if the focus is on the body element after unmounting.\n        var observer = new MutationObserver(function () {\n            if (document.activeElement === document.body) {\n                dragControlContext.unlock();\n            }\n        });\n        observer.observe(node, {\n            subtree: true,\n            childList: true,\n        });\n        node.addEventListener(\"mouseover\", handleMouseOver);\n        node.addEventListener(\"mouseout\", handleMouseOut);\n        node.addEventListener(\"focusin\", handleFocusIn);\n        node.addEventListener(\"focusout\", handleFocusOut);\n        return function () {\n            observer.disconnect();\n            node.removeEventListener(\"mouseover\", handleMouseOver);\n            node.removeEventListener(\"mouseout\", handleMouseOut);\n            node.removeEventListener(\"focusin\", handleFocusIn);\n            node.removeEventListener(\"focusout\", handleFocusOut);\n        };\n    }, [ref, dragControlContext]);\n    useEffect(function () {\n        var _a;\n        (_a = ref.current) === null || _a === void 0 ? void 0 : _a.setAttribute(\"draggable\", dragControlContext.isLock ? \"false\" : \"true\");\n    }, [ref, dragControlContext.isLock]);\n};\n\nvar ItemTypes = {\n    TREE_ITEM: Symbol(),\n};\n\nvar dragSourceElement = null;\nvar register = function (e) {\n    var target = e.target;\n    if (target instanceof HTMLElement) {\n        var source = target.closest('[role=\"listitem\"]');\n        if (e.currentTarget === source) {\n            dragSourceElement = source;\n        }\n    }\n};\nvar handleDragStart = function (e) { return register(e); };\nvar handleTouchStart = function (e) { return register(e); };\nvar useDragNode = function (item, ref) {\n    var treeContext = useTreeContext();\n    useEffect(function () {\n        var node = ref.current;\n        node === null || node === void 0 ? void 0 : node.addEventListener(\"dragstart\", handleDragStart);\n        node === null || node === void 0 ? void 0 : node.addEventListener(\"touchstart\", handleTouchStart, {\n            passive: true,\n        });\n        return function () {\n            node === null || node === void 0 ? void 0 : node.removeEventListener(\"dragstart\", handleDragStart);\n            node === null || node === void 0 ? void 0 : node.removeEventListener(\"touchstart\", handleTouchStart);\n        };\n    }, [ref]);\n    var _a = useDrag({\n        type: ItemTypes.TREE_ITEM,\n        item: function (monitor) {\n            var dragItem = __assign({ ref: ref }, item);\n            if (treeContext.onDragStart) {\n                treeContext.onDragStart(dragItem, monitor);\n            }\n            return dragItem;\n        },\n        end: function (item, monitor) {\n            var dragItem = item;\n            if (treeContext.onDragEnd) {\n                treeContext.onDragEnd(dragItem, monitor);\n            }\n        },\n        canDrag: function () {\n            var canDrag = treeContext.canDrag;\n            if (dragSourceElement !== ref.current) {\n                return false;\n            }\n            if (canDrag) {\n                return canDrag(item.id);\n            }\n            return true;\n        },\n        collect: function (monitor) { return ({\n            isDragging: monitor.isDragging(),\n        }); },\n    }), isDragging = _a[0].isDragging, drag = _a[1], preview = _a[2];\n    return [isDragging, drag, preview];\n};\n\nvar useDragOver = function (id, isOpen, dragOverHandler) {\n    var stack = useRef(0);\n    var timer = useRef(0);\n    var onDragEnter = function () {\n        stack.current += 1;\n        if (stack.current === 1 && !isOpen) {\n            timer.current = window.setTimeout(function () { return dragOverHandler(id); }, 500);\n        }\n    };\n    var onDragLeave = function () {\n        stack.current -= 1;\n        if (stack.current === 0) {\n            window.clearTimeout(timer.current);\n        }\n    };\n    var onDrop = function () {\n        if (timer.current > 0) {\n            window.clearTimeout(timer.current);\n        }\n        stack.current = 0;\n        timer.current = 0;\n    };\n    return {\n        onDragEnter: onDragEnter,\n        onDragLeave: onDragLeave,\n        onDrop: onDrop,\n    };\n};\n\nvar useDropRoot = function (ref) {\n    var treeContext = useTreeContext();\n    var placeholderContext = useContext(PlaceholderContext);\n    var _a = useDrop({\n        accept: __spreadArray([ItemTypes.TREE_ITEM], treeContext.extraAcceptTypes, true),\n        drop: function (dragItem, monitor) {\n            var rootId = treeContext.rootId, onDrop = treeContext.onDrop;\n            var dropTargetId = placeholderContext.dropTargetId, index = placeholderContext.index;\n            if (monitor.isOver({ shallow: true }) &&\n                dropTargetId !== undefined &&\n                index !== undefined) {\n                // If the drag source is outside the react-dnd,\n                // a different object is passed than the NodeModel.\n                onDrop(isNodeModel(dragItem) ? dragItem : null, rootId, index);\n            }\n            placeholderContext.hidePlaceholder();\n        },\n        canDrop: function (dragItem, monitor) {\n            var rootId = treeContext.rootId;\n            if (monitor.isOver({ shallow: true })) {\n                if (dragItem === undefined) {\n                    return false;\n                }\n                return isDroppable(dragItem, rootId, treeContext);\n            }\n            return false;\n        },\n        hover: function (dragItem, monitor) {\n            if (monitor.isOver({ shallow: true })) {\n                var rootId = treeContext.rootId;\n                var dropTargetId = placeholderContext.dropTargetId, index = placeholderContext.index, showPlaceholder = placeholderContext.showPlaceholder, hidePlaceholder = placeholderContext.hidePlaceholder;\n                var dropTarget = getDropTarget(null, ref.current, monitor, treeContext);\n                if (dropTarget === null ||\n                    !isDroppable(dragItem, rootId, treeContext)) {\n                    hidePlaceholder();\n                    return;\n                }\n                if (dropTarget.id !== dropTargetId || dropTarget.index !== index) {\n                    showPlaceholder(dropTarget.id, dropTarget.index);\n                }\n            }\n        },\n        collect: function (monitor) {\n            var dragSource = monitor.getItem();\n            return {\n                isOver: monitor.isOver({ shallow: true }) && monitor.canDrop(),\n                dragSource: dragSource,\n            };\n        },\n    }), _b = _a[0], isOver = _b.isOver, dragSource = _b.dragSource, drop = _a[1];\n    return [isOver, dragSource, drop];\n};\n\nvar useDropNode = function (item, ref) {\n    var treeContext = useTreeContext();\n    var placeholderContext = useContext(PlaceholderContext);\n    var _a = useDrop({\n        accept: __spreadArray([ItemTypes.TREE_ITEM], treeContext.extraAcceptTypes, true),\n        drop: function (dragItem, monitor) {\n            var dropTargetId = placeholderContext.dropTargetId, index = placeholderContext.index;\n            if (monitor.isOver({ shallow: true }) &&\n                dropTargetId !== undefined &&\n                index !== undefined) {\n                // If the drag source is outside the react-dnd,\n                // a different object is passed than the NodeModel.\n                treeContext.onDrop(isNodeModel(dragItem) ? dragItem : null, dropTargetId, index);\n            }\n            placeholderContext.hidePlaceholder();\n        },\n        canDrop: function (dragItem, monitor) {\n            if (monitor.isOver({ shallow: true })) {\n                var dropTarget = getDropTarget(item, ref.current, monitor, treeContext);\n                if (dropTarget === null) {\n                    return false;\n                }\n                return isDroppable(dragItem, dropTarget.id, treeContext);\n            }\n            return false;\n        },\n        hover: function (dragItem, monitor) {\n            if (monitor.isOver({ shallow: true })) {\n                var dropTargetId = placeholderContext.dropTargetId, index = placeholderContext.index, showPlaceholder = placeholderContext.showPlaceholder, hidePlaceholder = placeholderContext.hidePlaceholder;\n                var dropTarget = getDropTarget(item, ref.current, monitor, treeContext);\n                if (dropTarget === null ||\n                    !isDroppable(dragItem, dropTarget.id, treeContext)) {\n                    hidePlaceholder();\n                    return;\n                }\n                if (dropTarget.id !== dropTargetId || dropTarget.index !== index) {\n                    showPlaceholder(dropTarget.id, dropTarget.index);\n                }\n            }\n        },\n        collect: function (monitor) {\n            var dragSource = monitor.getItem();\n            return {\n                isOver: monitor.isOver({ shallow: true }) && monitor.canDrop(),\n                dragSource: dragSource,\n            };\n        },\n    }), _b = _a[0], isOver = _b.isOver, dragSource = _b.dragSource, drop = _a[1];\n    return [isOver, dragSource, drop];\n};\n\nvar useOpenIdsHelper = function (tree, initialOpen) {\n    // Only a parent node with a child node can be opened.\n    // The droppable property has no effect.\n    // However, if an ID is specified, It is applied unconditionally.\n    var initialOpenIds = useMemo(function () {\n        if (initialOpen === true) {\n            return tree\n                .filter(function (node) { return hasChildNodes(tree, node.id); })\n                .map(function (node) { return node.id; });\n        }\n        else if (Array.isArray(initialOpen)) {\n            return initialOpen;\n        }\n        return [];\n    }, [initialOpen]);\n    var _a = useState(initialOpenIds), openIds = _a[0], setOpenIds = _a[1];\n    useEffect(function () { return setOpenIds(initialOpenIds); }, [initialOpen]);\n    var handleToggle = function (targetId, callback) {\n        var newOpenIds = openIds.includes(targetId)\n            ? openIds.filter(function (id) { return id !== targetId; })\n            : __spreadArray(__spreadArray([], openIds, true), [targetId], false);\n        setOpenIds(newOpenIds);\n        if (callback) {\n            callback(newOpenIds);\n        }\n    };\n    var handleCloseAll = function (callback) {\n        setOpenIds([]);\n        if (callback) {\n            callback([]);\n        }\n    };\n    var handleOpenAll = function (callback) {\n        var newOpenIds = tree\n            .filter(function (node) { return hasChildNodes(tree, node.id); })\n            .map(function (node) { return node.id; });\n        setOpenIds(newOpenIds);\n        if (callback) {\n            callback(newOpenIds);\n        }\n    };\n    var handleOpen = function (targetIds, callback) {\n        var newOpenIds = [];\n        if (Array.isArray(targetIds)) {\n            var targetNodes = tree.filter(function (node) { return targetIds.includes(node.id) && hasChildNodes(tree, node.id); });\n            newOpenIds = __spreadArray(__spreadArray([], openIds, true), targetNodes.map(function (node) { return node.id; }), true).filter(function (value, index, self) { return self.indexOf(value) === index; });\n        }\n        else {\n            newOpenIds = openIds.includes(targetIds)\n                ? openIds\n                : __spreadArray(__spreadArray([], openIds, true), [targetIds], false);\n        }\n        setOpenIds(newOpenIds);\n        if (callback) {\n            callback(newOpenIds);\n        }\n    };\n    var handleClose = function (targetIds, callback) {\n        var newOpenIds = openIds.filter(function (id) {\n            return Array.isArray(targetIds) ? !targetIds.includes(id) : id !== targetIds;\n        });\n        setOpenIds(newOpenIds);\n        if (callback) {\n            callback(newOpenIds);\n        }\n    };\n    return [\n        openIds,\n        { handleToggle: handleToggle, handleCloseAll: handleCloseAll, handleOpenAll: handleOpenAll, handleOpen: handleOpen, handleClose: handleClose },\n    ];\n};\n\nvar useTreeDragLayer = function () {\n    return useDragLayer(function (monitor) {\n        var itemType = monitor.getItemType();\n        return {\n            item: monitor.getItem(),\n            clientOffset: monitor.getClientOffset(),\n            isDragging: monitor.isDragging() && itemType === ItemTypes.TREE_ITEM,\n        };\n    });\n};\n\nvar useTreeContext = function () {\n    var treeContext = useContext(TreeContext);\n    if (!treeContext) {\n        throw new Error(\"useTreeContext must be used under TreeProvider\");\n    }\n    return treeContext;\n};\n\nvar useContainerClassName = function (parentId, isOver) {\n    var _a = useTreeContext(), rootId = _a.rootId, rootProps = _a.rootProps, classes = _a.classes;\n    var className = (classes === null || classes === void 0 ? void 0 : classes.container) || \"\";\n    if (isOver && (classes === null || classes === void 0 ? void 0 : classes.dropTarget)) {\n        className = \"\".concat(className, \" \").concat(classes.dropTarget);\n    }\n    if (parentId === rootId && (classes === null || classes === void 0 ? void 0 : classes.root)) {\n        className = \"\".concat(className, \" \").concat(classes.root);\n    }\n    if (parentId === rootId && (rootProps === null || rootProps === void 0 ? void 0 : rootProps.className)) {\n        className = \"\".concat(className, \" \").concat(rootProps.className);\n    }\n    className = className.trim();\n    return className;\n};\n\nvar useDragHandle = function (containerRef, handleRef, drag) {\n    if (handleRef.current) {\n        drag(handleRef);\n    }\n    else {\n        drag(containerRef);\n    }\n    useEffect(function () {\n        if (handleRef.current) {\n            drag(handleRef);\n        }\n        else {\n            drag(containerRef);\n        }\n    }, [handleRef.current]);\n};\n\nvar Node = function (props) {\n    var treeContext = useTreeContext();\n    var placeholderContext = useContext(PlaceholderContext);\n    var containerRef = useRef(null);\n    var handleRef = useRef(null);\n    var item = treeContext.tree.find(function (node) { return node.id === props.id; });\n    var openIds = treeContext.openIds, classes = treeContext.classes, enableAnimateExpand = treeContext.enableAnimateExpand;\n    var open = openIds.includes(props.id);\n    var _a = useDragNode(item, containerRef), isDragging = _a[0], drag = _a[1], preview = _a[2];\n    var _b = useDropNode(item, containerRef), isOver = _b[0], dragSource = _b[1], drop = _b[2];\n    useDragHandle(containerRef, handleRef, drag);\n    if (isDroppable(dragSource, props.id, treeContext)) {\n        drop(containerRef);\n    }\n    useEffect(function () {\n        if (treeContext.dragPreviewRender) {\n            preview(getEmptyImage(), { captureDraggingState: true });\n        }\n        else if (handleRef.current) {\n            preview(containerRef);\n        }\n    }, [preview, treeContext.dragPreviewRender]);\n    useDragControl(containerRef);\n    var handleToggle = function () { return treeContext.onToggle(item.id); };\n    var Component = treeContext.listItemComponent;\n    var className = (classes === null || classes === void 0 ? void 0 : classes.listItem) || \"\";\n    if (isOver && (classes === null || classes === void 0 ? void 0 : classes.dropTarget)) {\n        className = \"\".concat(className, \" \").concat(classes.dropTarget);\n    }\n    if (isDragging && (classes === null || classes === void 0 ? void 0 : classes.draggingSource)) {\n        className = \"\".concat(className, \" \").concat(classes.draggingSource);\n    }\n    var draggable = treeContext.canDrag ? treeContext.canDrag(props.id) : true;\n    var isDropTarget = placeholderContext.dropTargetId === props.id;\n    var params = {\n        depth: props.depth,\n        isOpen: open,\n        isDragging: isDragging,\n        isDropTarget: isDropTarget,\n        draggable: draggable,\n        hasChild: hasChildNodes(treeContext.tree, props.id),\n        containerRef: containerRef,\n        handleRef: handleRef,\n        onToggle: handleToggle,\n    };\n    return (React.createElement(Component, { ref: containerRef, className: className, role: \"listitem\" },\n        treeContext.render(item, params),\n        enableAnimateExpand && params.hasChild && (React.createElement(AnimateHeight, { isVisible: open },\n            React.createElement(Container, { parentId: props.id, depth: props.depth + 1 }))),\n        !enableAnimateExpand && params.hasChild && open && (React.createElement(Container, { parentId: props.id, depth: props.depth + 1 }))));\n};\n\nvar Placeholder = function (props) {\n    var _a = useTreeContext(), placeholderRender = _a.placeholderRender, Component = _a.placeholderComponent, classes = _a.classes;\n    var placeholderContext = useContext(PlaceholderContext);\n    var manager = useDragDropManager();\n    var monitor = manager.getMonitor();\n    var dragSource = monitor.getItem();\n    if (!placeholderRender || !dragSource) {\n        return null;\n    }\n    var visible = props.dropTargetId === placeholderContext.dropTargetId &&\n        (props.index === placeholderContext.index ||\n            (props.index === undefined &&\n                props.listCount === placeholderContext.index));\n    if (!visible) {\n        return null;\n    }\n    return (React.createElement(Component, { className: (classes === null || classes === void 0 ? void 0 : classes.placeholder) || \"\" }, placeholderRender(dragSource, { depth: props.depth })));\n};\n\nvar Container = function (props) {\n    var treeContext = useTreeContext();\n    var ref = useRef(null);\n    var nodes = treeContext.tree.filter(function (l) { return l.parent === props.parentId; });\n    var view = nodes;\n    var sortCallback = typeof treeContext.sort === \"function\" ? treeContext.sort : compareItems;\n    if (treeContext.insertDroppableFirst) {\n        var droppableNodes = nodes.filter(function (n) { return n.droppable; });\n        var nonDroppableNodes = nodes.filter(function (n) { return !n.droppable; });\n        if (treeContext.sort === false) {\n            view = __spreadArray(__spreadArray([], droppableNodes, true), nonDroppableNodes, true);\n        }\n        else {\n            droppableNodes = droppableNodes.sort(sortCallback);\n            nonDroppableNodes = nonDroppableNodes.sort(sortCallback);\n            view = __spreadArray(__spreadArray([], droppableNodes, true), nonDroppableNodes, true);\n        }\n    }\n    else {\n        if (treeContext.sort !== false) {\n            view = nodes.sort(sortCallback);\n        }\n    }\n    var _a = useDropRoot(ref), isOver = _a[0], dragSource = _a[1], drop = _a[2];\n    if (props.parentId === treeContext.rootId &&\n        isDroppable(dragSource, treeContext.rootId, treeContext)) {\n        drop(ref);\n    }\n    var className = useContainerClassName(props.parentId, isOver);\n    var rootProps = treeContext.rootProps || {};\n    var Component = treeContext.listComponent;\n    return (React.createElement(Component, __assign({ ref: ref, role: \"list\" }, rootProps, { className: className }),\n        view.map(function (node, index) { return (React.createElement(React.Fragment, { key: node.id },\n            React.createElement(Placeholder, { depth: props.depth, listCount: view.length, dropTargetId: props.parentId, index: index }),\n            React.createElement(Node, { id: node.id, depth: props.depth }))); }),\n        React.createElement(Placeholder, { depth: props.depth, listCount: view.length, dropTargetId: props.parentId })));\n};\n\nvar rootStyle = {\n    height: \"100%\",\n    left: 0,\n    pointerEvents: \"none\",\n    position: \"fixed\",\n    top: 0,\n    width: \"100%\",\n    zIndex: 100,\n};\nvar getItemStyles = function (monitorProps) {\n    var offset = monitorProps.clientOffset;\n    if (!offset) {\n        return {};\n    }\n    var x = offset.x, y = offset.y;\n    var transform = \"translate(\".concat(x, \"px, \").concat(y, \"px)\");\n    return {\n        pointerEvents: \"none\",\n        transform: transform,\n    };\n};\nvar DragLayer = function () {\n    var context = useTreeContext();\n    var monitorProps = useTreeDragLayer();\n    var isDragging = monitorProps.isDragging, clientOffset = monitorProps.clientOffset;\n    if (!isDragging || !clientOffset) {\n        return null;\n    }\n    return (React.createElement(\"div\", { style: rootStyle },\n        React.createElement(\"div\", { style: getItemStyles(monitorProps) }, context.dragPreviewRender && context.dragPreviewRender(monitorProps))));\n};\n\nfunction TreeInner(props, ref) {\n    return (React.createElement(Providers, __assign({}, props, { treeRef: ref }),\n        props.dragPreviewRender && React.createElement(DragLayer, null),\n        React.createElement(Container, { parentId: props.rootId, depth: 0 })));\n}\nvar Tree = forwardRef(TreeInner);\n\nexport { Container, DragLayer, ItemTypes, Node, Tree, compareItems, getBackendOptions, getDescendants, getDestIndex, getDropTarget, getModifiedIndex, getParents, getTreeItem, hasChildNodes, isAncestor, isDroppable, isNodeModel, mutateTree, mutateTreeWithIndex, useContainerClassName, useDragControl, useDragHandle, useDragNode, useDragOver, useDropNode, useDropRoot, useOpenIdsHelper, useTreeContext, useTreeDragLayer };\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}